/*
 * THIS FILE IS AUTOMATICALLY GENERATED
 *
 * I2C-Generator: 0.2.0
 * Yaml Version: 1.1.0
 * Template Version: 0.7.0-32-g81a7f63
 */
/*
 * Copyright (c) 2021, Sensirion AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Sensirion AG nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef SENSIRIONI2CSEN55_H
#define SENSIRIONI2CSEN55_H

#include <Wire.h>

#include <SensirionCore.h>

class SensirionI2CSen55 {

  public:
    SensirionI2CSen55();
    /**
     * begin() - Initializes the SensirionI2CSen55 class.
     *
     * @param serial Arduino stream object to be communicated with.
     *
     */
    void begin(TwoWire& i2cBus);

    /**
     * startMeasurement() - Starts a continuous measurement.
     *
     * @note After starting the measurement, it takes some time (~1s) until the
     * first measurement results are available. You could poll with the command
     * 0x0202 \"Read Data Ready\" to check when the results are ready to read.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t startMeasurement(void);

    /**
     * stopMeasurement() - Stops the measurement and returns to idle mode.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t stopMeasurement(void);

    /**
     * readDataReady() - This command can be used to check if new measurement
     * results are ready to read. The data ready flag is automatically reset
     * after reading the measurement values with the 0x03.. \"Read Measured
     * Values\" commands.
     *
     * @note During fan (auto-)cleaning, no measurement data is available for
     * several seconds and thus this flag will not be set until cleaning has
     * finished. So please expect gaps of several seconds at any time if fan
     * auto-cleaning is enabled.
     *
     * @param padding Padding byte, always 0x00.
     *
     * @param dataReady True (0x01) if data is ready, False (0x00) if not.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t readDataReady(bool& dataReady);

    /**
     * readMeasuredPmValuesFloat() - Returns the measured particulate matter
     * values as floating point numbers. The command 0x0202 \"Read Data Ready\"
     * can be used to check if new data is available since the last read
     * operation. If no new data is available, the previous values will be
     * returned again. If no data is available at all (e.g. measurement not
     * running for at least one Second), NaN is returned for all values.
     *
     * @param massConcentrationPm1p0 Value is returned in the unit µg/m³.
     *
     * @param massConcentrationPm2p5 Value is returned in the unit µg/m³.
     *
     * @param massConcentrationPm4p0 Value is returned in the unit µg/m³.
     *
     * @param massConcentrationPm10p0 Value is returned in the unit µg/m³.
     *
     * @param numberConcentrationPm0p5 Value is returned in the unit #/cm³.
     *
     * @param numberConcentrationPm1p0 Value is returned in the unit #/cm³.
     *
     * @param numberConcentrationPm2p5 Value is returned in the unit #/cm³.
     *
     * @param numberConcentrationPm4p0 Value is returned in the unit #/cm³.
     *
     * @param numberConcentrationPm10p0 Value is returned in the unit #/cm³.
     *
     * @param typicalParticleSize Value is returned in the unit µm.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t readMeasuredPmValuesFloat(
        float& massConcentrationPm1p0, float& massConcentrationPm2p5,
        float& massConcentrationPm4p0, float& massConcentrationPm10p0,
        float& numberConcentrationPm0p5, float& numberConcentrationPm1p0,
        float& numberConcentrationPm2p5, float& numberConcentrationPm4p0,
        float& numberConcentrationPm10p0, float& typicalParticleSize);

    /**
     * readMeasuredValues() - Returns the measured values. The command 0x0202
    \"Read Data Ready\" can be used to check if new data is available since the
    last read operation. If no new data is available, the previous values will
    be returned again. If no data is available at all (e.g. measurement not
    running for at least one Second), all values will be at their upper limit
    (0xFFFF for `uint16`, 0x7FFF for `int16`).
     *
     * @param massConcentrationPm1p0 Value is scaled with factor 10: PM1.0
    [µg/m³] = value / 10

    *Note: If this value is unknown, 0xFFFF is returned.*
     *
     * @param massConcentrationPm2p5 Value is scaled with factor 10: PM2.5
    [µg/m³] = value / 10

    *Note: If this value is unknown, 0xFFFF is returned.*
     *
     * @param massConcentrationPm4p0 Value is scaled with factor 10: PM4.0
    [µg/m³] = value / 10

    *Note: If this value is unknown, 0xFFFF is returned.*
     *
     * @param massConcentrationPm10p0 Value is scaled with factor 10: PM10.0
    [µg/m³] = value / 10

    *Note: If this value is unknown, 0xFFFF is returned.*
     *
     * @param ambientHumidity Value is scaled with factor 100: RH [%] = value /
    100

    *Note: If this value is unknown, 0x7FFF is returned.*
     *
     * @param ambientTemperature Value is scaled with factor 200: T [°C] = value
    / 200

    *Note: If this value is unknown, 0x7FFF is returned.*
     *
     * @param vocIndex Value is scaled with factor 10: VOC Index = value / 10

    *Note: If this value is unknown, 0x7FFF is returned.*

    **Attention: This feature is not available yet, thus currently the
    value 0x7FFF is returned.**
     *
     * @param noxIndex Value is scaled with factor 10: NOx Index = value / 10

    *Note: If this value is unknown, 0x7FFF is returned.*

    **Attention: This feature is not available yet, thus currently the
    value 0x7FFF is returned.**
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t readMeasuredValues(uint16_t& massConcentrationPm1p0,
                                uint16_t& massConcentrationPm2p5,
                                uint16_t& massConcentrationPm4p0,
                                uint16_t& massConcentrationPm10p0,
                                int16_t& ambientHumidity,
                                int16_t& ambientTemperature, int16_t& vocIndex,
                                int16_t& noxIndex);

    /**
     * readMeasuredRawValues() - Returns the measured raw values. The command
    0x0202 \"Read Data Ready\" can be used to check if new data is available
    since the last read operation. If no new data is available, the previous
    values will be returned again. If no data is available at all (e.g.
    measurement not running for at least one Second), all values will be at
    their upper limit (0xFFFF for `uint16`, 0x7FFF for `int16`).
     *
     * @param rawHumidity Value is scaled with factor 100: RH [%] = value / 100

    *Note: If this value is unknown, 0x7FFF is returned.*
     *
     * @param rawTemperature Value is scaled with factor 200: T [°C] = value /
    200

    *Note: If this value is unknown, 0x7FFF is returned.*
     *
     * @param rawVoc Raw measured VOC ticks without scale factor.

    *Note: If this value is unknown, 0xFFFF is returned.*
     *
     * @param rawNox Raw measured NOx ticks without scale factor.

    *Note: If this value is unknown, 0xFFFF is returned. During
    the first 10 seconds after power-on or device reset, this
    value will not be available.*
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t readMeasuredRawValues(int16_t& rawHumidity,
                                   int16_t& rawTemperature, uint16_t& rawVoc,
                                   uint16_t& rawNox);

    /**
     * startFanCleaning() - Starts the fan cleaning manually. The \"data
    ready\"-flag will be cleared immediately and during the next few seconds, no
    new measurement results will be available (old values will be returned).
    Once the cleaning is finished, the \"data ready\"-flag will be set and new
    measurement results will be available.

    When executing this command while cleaning is already active, the
    command does nothing.

    If you stop the measurement while fan cleaning is active, the cleaning
    will be aborted immediately.
     *
     * @note This command is only available in measure mode with PM measurement
    enabled, i.e. only if the fan is already running. In any other state, this
    command does nothing.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t startFanCleaning(void);

    /**
     * setTemperatureOffsetParameters() - Sets the temperature offset parameters
     * for the device.
     *
     * @note This configuration is volatile, i.e. the parameters will be
     * reverted to their default value of zero after a device reset.
     *
     * @param tempOffset Constant temperature offset scaled with factor 200 (T
     * [°C] = value / 200).
     *
     * @param slope Normalized temperature offset slope scaled with factor 10000
     * (applied factor = value / 10000).
     *
     * @param timeConstant Time constant [s] how fast the new slope and offset
     * will be applied. After the specified value in seconds, 63% of the new
     * slope and offset are applied. A time constant of zero means the new
     * values will be applied immediately (within the next measure interval of 1
     * second).
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t setTemperatureOffsetParameters(int16_t tempOffset, int16_t slope,
                                            uint16_t timeConstant);

    /**
     * getTemperatureOffsetParameters() - Gets the temperature offset parameters
     * from the device.
     *
     * @param tempOffset Constant temperature offset scaled with factor 200 (T
     * [°C] = value / 200).
     *
     * @param slope Normalized temperature offset slope scaled with factor 10000
     * (applied factor = value / 10000).
     *
     * @param timeConstant Time constant [s] how fast the slope and offset are
     * applied. After the specified value in seconds, 63% of the new slope and
     * offset are applied.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t getTemperatureOffsetParameters(int16_t& tempOffset, int16_t& slope,
                                            uint16_t& timeConstant);

    /**
     * setWarmStartParameter() - Sets the warm start parameter for the device.
     *
     * @note This configuration is volatile, i.e. the parameter will be reverted
     * to its default value of zero after a device reset.
     *
     * @param warmStart Warm start behavior as a value in the range from 0 (cold
     * start, default value) to 65535 (warm start).
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t setWarmStartParameter(uint16_t warmStart);

    /**
     * getWarmStartParameter() - Gets the warm start parameter from the device.
     *
     * @param warmStart Warm start behavior as a value in the range from 0 (cold
     * start, default value) to 65535 (warm start).
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t getWarmStartParameter(uint16_t& warmStart);

    /**
     * setFanAutoCleaningInterval() - Sets the fan auto cleaning interval for
     * the device.
     *
     * @note This configuration is volatile, i.e. it will be reverted to the
     * default value after a device reset.
     *
     * @param interval Fan auto cleaning interval [s]. Set to zero to disable
     * auto cleaning.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t setFanAutoCleaningInterval(uint32_t interval);

    /**
     * getFanAutoCleaningInterval() - Gets the fan auto cleaning interval from
     * the device.
     *
     * @param interval Fan auto cleaning interval [s]. Zero means auto cleaning
     * is disabled.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t getFanAutoCleaningInterval(uint32_t& interval);

    /**
     * getProductName() - Gets the product name from the device.
     *
     * @param productName Null-terminated ASCII string containing the product
     * name. Up to 32 characters can be read from the device.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t getProductName(unsigned char productName[],
                            uint8_t productNameSize);

    /**
     * getSerialNumber() - Gets the serial number from the device.
     *
     * @param serialNumber Null-terminated ASCII string containing the serial
     * number. Up to 32 characters can be read from the device.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t getSerialNumber(unsigned char serialNumber[],
                             uint8_t serialNumberSize);

    /**
     * getVersion() - Gets the version information for the hardware, firmware
     * and communication protocol.
     *
     * @param firmwareMajor Firmware major version number.
     *
     * @param firmwareMinor Firmware minor version number.
     *
     * @param firmwareDebug Firmware debug state. If the debug state is set, the
     * firmware is in development.
     *
     * @param hardwareMajor Hardware major version number.
     *
     * @param hardwareMinor Hardware minor version number.
     *
     * @param protocolMajor Protocol major version number.
     *
     * @param protocolMinor Protocol minor version number.
     *
     * @param padding Padding byte, ignore this.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t getVersion(uint8_t& firmwareMajor, uint8_t& firmwareMinor,
                        bool& firmwareDebug, uint8_t& hardwareMajor,
                        uint8_t& hardwareMinor, uint8_t& protocolMajor,
                        uint8_t& protocolMinor);

    /**
     * readDeviceStatus() - Reads the current device status. Use this command to
     * get detailed information about the device status. The device status is
     * encoded in flags. Each device status flag represents a single bit in a
     * 32-bit integer value. If more than one error is present, the device
     * status register value is the sum of the corresponding flag values. For
     * details about the available flags, refer to the device status flags
     * documentation.
     *
     * @note The status flags of type \"Error\" are sticky, i.e. they are not
     * cleared automatically even if the error condition no longer exists. So
     * they can only be cleared manually with the command 0xD210 \"Read And
     * Clear Device Status\" or with a device reset. All other flags are not
     * sticky, i.e. they are cleared automatically if the trigger condition
     * disappears.
     *
     * @param deviceStatus Device status (32 flags as an integer value). For
     * details, please refer to the device status flags documentation.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t readDeviceStatus(uint32_t& deviceStatus);

    /**
     * readAndClearDeviceStatus() - Reads the current device status. (like
     * command 0xD206 \"Read Device Status\") and afterwards clears all flags.
     *
     * @param deviceStatus Device status (32 flags as an integer value)
     * **before** clearing it. For details, please refer to the device status
     * flags documentation.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t readAndClearDeviceStatus(uint32_t& deviceStatus);

    /**
     * deviceReset() - Executes a reset on the device. This has the same effect
     * as a power cycle.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t deviceReset(void);

  private:
    TwoWire* _i2cBus = nullptr;
};

#endif /* SENSIRIONI2CSEN55_H */
